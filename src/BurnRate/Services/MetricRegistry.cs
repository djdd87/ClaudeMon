using BurnRate.Models;

namespace BurnRate.Services;

/// <summary>
/// Describes a single displayable metric: how to label it and extract its formatted value from a UsageSummary.
/// </summary>
public sealed record MetricDefinition(
    string Id,
    string Label,
    string Hint,
    Func<UsageSummary, string> GetValue);

/// <summary>
/// Registry of all available dashboard metrics, in the preferred display order.
/// Add new metrics here to make them available in the metrics configuration menu.
/// </summary>
public static class MetricRegistry
{
    private static string FormatTokens(long tokens) => tokens switch
    {
        < 1_000 => tokens.ToString(),
        < 1_000_000 => $"{tokens / 1_000.0:0.#}K",
        _ => $"{tokens / 1_000_000.0:0.#}M"
    };

    public static readonly IReadOnlyList<MetricDefinition> All =
    [
        new("UsageLimits",
            "USAGE LIMITS",
            "Live API usage limit bars (session, weekly, sonnet, extra). Only visible when live data is available.",
            u => u.IsLive ? "Live" : "—"),

        new("TodayMessages",
            "TODAY MSGS",
            "Total human messages sent to Claude today. Excludes tool results and system-injected content.",
            u => u.TodayMessages.ToString()),

        new("TodayTokens",
            "TODAY OUT TOKENS",
            "Output tokens generated by Claude today. Cache creation/read tokens are excluded to avoid inflated counts.",
            u => FormatTokens(u.TodayTokens)),

        new("TodaySessions",
            "TODAY SESSIONS",
            "Number of conversations started today. Each conversation file with at least one human message counts as one session.",
            u => u.TodaySessions.ToString()),

        new("WeeklyTokens",
            "WEEKLY TOKENS",
            "Total output tokens used in the current 7-day rolling window, read live from conversation files.",
            u => FormatTokens(u.WeeklyTokensUsed)),

        new("DailyBurn",
            "DAILY BURN",
            "Average output tokens consumed per day in the current window (weekly total ÷ days elapsed since reset).",
            u => u.DailyBurnRateText),

        new("Runway",
            "WEEKLY RUNWAY",
            "Estimated days until the weekly token limit is reached at the current daily burn rate. 'Resets first' means the window resets before you'd hit the limit. 'At limit' means you've reached or exceeded your weekly token cap — new requests will be blocked until the window resets.",
            u => u.RunwayText),

        new("SessionRunway",
            "SESSION RUNWAY",
            "Estimated time until the 5-hour session limit is reached at the current session burn rate. Requires live API data. 'Resets first' means the session window resets before you'd hit the cap. 'At limit' means the session is at or above 99.5% — you're effectively rate-limited until the session resets.",
            u => u.SessionRunwayText),

        new("EstimatedCost",
            "EST. COST",
            "Lifetime estimated API-equivalent cost in USD across all Claude models (from stats-cache).",
            u => u.EstimatedCostUsd == 0 ? "—" : $"${u.EstimatedCostUsd:F2}"),

        new("TimeSaved",
            "TIME SAVED",
            "Total speculative pre-execution time saved by Claude Code, as reported by stats-cache.",
            u => u.TimeSavedFormatted),

        new("LifetimeSessions",
            "LIFETIME SESSIONS",
            "Total number of conversations across all time (from stats-cache).",
            u => u.TotalSessions.ToString()),

        new("LifetimeMessages",
            "LIFETIME MSGS",
            "Total number of human messages across all time (from stats-cache).",
            u => u.TotalMessages.ToString()),
    ];

    public static readonly IReadOnlyList<string> DefaultEnabled =
        ["UsageLimits", "TodaySessions", "WeeklyTokens", "DailyBurn", "Runway"];

    public static MetricDefinition? Find(string id) =>
        All.FirstOrDefault(d => d.Id == id);
}
